<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaggiuino Profile Generator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/canvas-toBlob.js/1.0.0/canvas-to-blob.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            height: 100vh;
            transition: background-color 0.3s, color 0.3s;
        }
        .container {
            display: flex;
            width: 100%;
            height: 100%;
        }
        .json-display {
            width: 33.33%;
            padding: 20px;
            overflow: auto;
            border-right: 1px solid #ccc;
            box-sizing: border-box;
        }
        .json-display .phase {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ddd;
            transition: background-color 0.3s;
        }
        .json-display .phase.highlight {
            background-color: #f0f8ff; /* Light blue highlight */
        }
        .json-display .metadata {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #f0f0f0; /* Light grey background */
        }
        .chart-display {
            width: 66.67%;
            padding: 20px;
            box-sizing: border-box;
        }
        .button-container {
            display: flex;
            align-items: center;
            width: 100%;
            margin-bottom: 10px;
        }
        .button-container a {
            margin-right: 20px;
        }
        .button-container a img {
            height: 40px; /* Adjust the height as needed */
        }
        .button-container button {
            margin: 0 5px;
        }
        #myChart {
            width: 100%;
            height: 100%;
        }
        .yagermeister-mode {
            background-color: #42ab42; /* Dark green background */
            color: #FFFFFF; /* White text */
        }
        .yagermeister-mode .button-container button {
            background-color: #32CD32; /* Lime green buttons */
            color: #000000; /* Black text */
        }
        .yagermeister-mode .json-display .phase.highlight {
            background-color: #90EE90; /* Light green highlight */
        }
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            .json-display {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #ccc;
            }
            .chart-display {
                display: none;
            }
        }
    </style>
</head>
<body>

    <div class="button-container">
        <a href="https://gaggiuino.github.io/#/" target="_blank">
            <img src="GAGGIUINO_LOGO_transp.png" alt="Gaggiuino Logo">
        </a>
        <input type="file" id="fileInput" accept=".json">
        <button id="exportButton">Export JSON</button>
        <button id="exportGraphButton">Export Graph</button>
        <button id="loadExampleButton">Load Example</button>
        <button id="addPhaseButton">Add Phase</button>
        <button id="removePhaseButton">Remove Phase</button>
        <button id="toggleYagermeisterButton">Y채germeister Mode</button>
    </div>
    <div class="container">
        <div class="json-display" id="jsonDisplay"></div>
        <div class="chart-display">
            <canvas id="myChart"></canvas>
        </div>
    </div>

    <script>
        // Function to generate transition data for curves (linear, ease in/out, ease in, ease out, instant)
        function applyTransition(transitionType, startValue, endValue, startTime, endTime, curveDuration, previousEndValue) {
            const data = [];
            const stepCount = Math.floor(curveDuration / 0.1); // 0.1s intervals

            if (transitionType === 'INSTANT') {
                // For INSTANT, ignore curve time and set start value as end value
                data.push({ x: startTime, y: endValue });
                data.push({ x: endTime, y: endValue });
            } else {
                for (let i = 0; i <= stepCount; i++) {
                    const time = startTime + i * 0.1;
                    let value;
                    const progress = i / stepCount;

                    switch(transitionType) {
                        case 'EASE_IN_OUT':
                            value = startValue + (endValue - startValue) * (0.5 - Math.cos(Math.PI * progress) / 2);
                            break;
                        case 'EASE_IN':
                            value = startValue + (endValue - startValue) * (progress * progress);
                            break;
                        case 'EASE_OUT':
                            value = startValue + (endValue - startValue) * (1 - (1 - progress) * (1 - progress));
                            break;
                        case 'LINEAR':
                        default:
                            value = startValue + (endValue - startValue) * progress;
                            break;
                    }

                    data.push({ x: time, y: value });
                }
            }
            return data;
        }

        let chart; // Variable to hold the chart instance.
        let phasesData = []; // Store phases data for highlighting
        let globalData = {}; // Store the global JSON data
        let isYagermeisterMode = false; // Track if Y채germeister Mode is active

        // Function to plot standard Gaggiuino profile
        function plotProfile(data) {
            globalData = data;
            const { phases, waterTemperature: globalWaterTemperature } = data;

            const globalTemperature = globalWaterTemperature || 20; // Default to 20째C if not present
            console.log(`Global Temperature: ${globalTemperature}째C`);

            const pressureData = []; // For pressure profile
            const flowData = []; // For flow profile
            const temperatureData = []; // Override if phase has temp
            const globalTemperatureData = [];
            const timeLabels = [];
            const phaseMarkers = [];
            const flowRestrictionData = [];  // For flow restrictions
            const pressureRestrictionData = [];  // For pressure restrictions
            const phaseAnnotations = []; // For phase names

            let currentTime = 0;
            let previousFlowEndValue = 0;
            let previousPressureEndValue = 0;
            let previousPhaseType = null;
            let previousRestrictionValue = 0;

            phases.forEach((phase, index) => {
                const { name, type, target, stopConditions, waterTemperature, restriction, transitionType } = phase;

                const phaseTime = stopConditions.time ? stopConditions.time / 1000 : 10; // Convert ms to seconds or use 10 seconds if not set
                const startTime = currentTime;
                const endTime = currentTime + phaseTime;
                const curveDuration = target.time / 1000; // Convert ms to seconds

                // Update the time labels
                timeLabels.push(startTime, endTime);

                // Apply transitions to Pressure or Flow data based on the type
                let transitionData = [];

                if (type === 'PRESSURE') {
                    // Handle pressure transition and apply any necessary restriction data
                    let startValue = target.start;
                    if (target.start === 0 && transitionType !== 'INSTANT') {
                        startValue = index === 0 ? target.end : (previousPhaseType === 'PRESSURE' ? previousPressureEndValue : previousRestrictionValue);
                    }
                    transitionData = applyTransition(target.curve, startValue, target.end, startTime, startTime + curveDuration, curveDuration);

                    // Extend the curve with a straight line if the curve duration is shorter than the phase duration
                    if (curveDuration < phaseTime) {
                        transitionData.push({ x: endTime, y: target.end });
                    } else {
                        // Intersect the curve at the end of the phase if the curve duration is longer
                        transitionData = transitionData.filter(point => point.x <= endTime);
                    }

                    pressureData.push(...transitionData, { x: endTime, y: null }); // Add null to disconnect phases
                    previousPressureEndValue = target.end;

                    if (restriction !== null) {
                        flowRestrictionData.push({ x: startTime, y: restriction, phase: 'FLOW' });
                        flowRestrictionData.push({ x: endTime, y: restriction, phase: 'FLOW' });
                        pressureRestrictionData.push({ x: startTime, y: 0, phase: 'PRESSURE' });
                        pressureRestrictionData.push({ x: endTime, y: 0, phase: 'PRESSURE' });
                        previousRestrictionValue = restriction;
                    } else {
                        flowRestrictionData.push({ x: startTime, y: previousRestrictionValue, phase: 'FLOW' });
                        flowRestrictionData.push({ x: endTime, y: previousRestrictionValue, phase: 'FLOW' });
                        pressureRestrictionData.push({ x: startTime, y: 0, phase: 'PRESSURE' });
                        pressureRestrictionData.push({ x: endTime, y: 0, phase: 'PRESSURE' });
                    }
                } else if (type === 'FLOW') {
                    // Handle flow transition and apply any necessary restriction data
                    let startValue = target.start;
                    if (target.start === 0 && transitionType !== 'INSTANT') {
                        startValue = index === 0 ? target.end : (previousPhaseType === 'FLOW' ? previousFlowEndValue : previousRestrictionValue);
                    }
                    transitionData = applyTransition(target.curve, startValue, target.end, startTime, startTime + curveDuration, curveDuration);

                    // Extend the curve with a straight line if the curve duration is shorter than the phase duration
                    if (curveDuration < phaseTime) {
                        transitionData.push({ x: endTime, y: target.end });
                    } else {
                        // Intersect the curve at the end of the phase if the curve duration is longer
                        transitionData = transitionData.filter(point => point.x <= endTime);
                    }

                    flowData.push(...transitionData, { x: endTime, y: null }); // Add null to disconnect phases
                    previousFlowEndValue = target.end;

                    if (restriction !== null) {
                        pressureRestrictionData.push({ x: startTime, y: restriction, phase: 'PRESSURE' });
                        pressureRestrictionData.push({ x: endTime, y: restriction, phase: 'PRESSURE' });
                        flowRestrictionData.push({ x: startTime, y: 0, phase: 'FLOW' });
                        flowRestrictionData.push({ x: endTime, y: 0, phase: 'FLOW' });
                        previousRestrictionValue = restriction;
                    } else {
                        pressureRestrictionData.push({ x: startTime, y: previousRestrictionValue, phase: 'PRESSURE' });
                        pressureRestrictionData.push({ x: endTime, y: previousRestrictionValue, phase: 'PRESSURE' });
                        flowRestrictionData.push({ x: startTime, y: 0, phase: 'FLOW' });
                        flowRestrictionData.push({ x: endTime, y: 0, phase: 'FLOW' });
                    }
                }

                globalTemperatureData.push(
                    { x: startTime, y: globalTemperature },
                    { x: endTime, y: globalTemperature }
                );

                if (waterTemperature !== 0) {
                    temperatureData.push(
                        { x: startTime, y: waterTemperature },
                        { x: endTime, y: waterTemperature }
                    );
                }

                phaseMarkers.push(startTime, endTime);

                // Add phase name annotations
                phaseAnnotations.push({
                    type: 'line',
                    scaleID: 'x',
                    value: startTime,
                    borderColor: 'gray',
                    borderWidth: 1,
                    label: {
                        content: name || `Phase ${index + 1}`,
                        position: 'start',
                        enabled: true,
                    },
                });

                // Store phase data for highlighting
                phasesData.push({
                    startTime,
                    endTime,
                    index
                });

                // Update previous phase type
                previousPhaseType = type;

                currentTime += phaseTime;
            });

            const uniqueTimeLabels = [...new Set(timeLabels)].sort((a, b) => a - b);

            if (chart) {
                chart.destroy();
            }

            chart = new Chart(document.getElementById('myChart'), {
                type: 'line',
                data: {
                    labels: uniqueTimeLabels,
                    datasets: [
                        {
                            label: 'Pressure',
                            data: pressureData,
                            borderColor: isYagermeisterMode ? 'green' : 'blue',
                            backgroundColor: isYagermeisterMode ? 'rgba(0, 255, 0, 0.1)' : 'rgba(0, 0, 255, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false,
                            tension: 0.4,
                            yAxisID: 'y1',
                        },
                        {
                            label: 'Flow',
                            data: flowData,
                            borderColor: isYagermeisterMode ? 'green' : 'orange',
                            backgroundColor: isYagermeisterMode ? 'rgba(0, 255, 0, 0.1)' : 'rgba(255, 165, 0, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false,
                            tension: 0.4,
                            yAxisID: 'y1',
                        },
                        {
                            label: 'Global Temperature',
                            data: globalTemperatureData,
                            borderColor: isYagermeisterMode ? 'green' : 'red',
                            backgroundColor: isYagermeisterMode ? 'rgba(0, 255, 0, 0.1)' : 'rgba(255, 0, 0, 0.1)',
                            borderWidth: 1,
                            pointRadius: 0,
                            fill: false,
                            tension: 0.4,
                            yAxisID: 'y2',
                        },
                        {
                            label: 'Phase Temperature',
                            data: temperatureData,
                            borderColor: isYagermeisterMode ? 'green' : 'red',
                            backgroundColor: isYagermeisterMode ? 'rgba(0, 255, 0, 0.1)' : 'rgba(255, 0, 0, 0.1)',
                            borderWidth: 2,
                            pointRadius: 5,
                            fill: false,
                            tension: 0.4,
                            yAxisID: 'y2',
                        },
                        {
                            label: 'Flow Restriction',
                            data: flowRestrictionData.map(item => ({
                                x: item.x,
                                y: item.y
                            })),
                            borderColor: isYagermeisterMode ? 'green' : 'orange',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            showLine: true,
                            yAxisID: 'y1',
                        },
                        {
                            label: 'Pressure Restriction',
                            data: pressureRestrictionData.map(item => ({
                                x: item.x,
                                y: item.y
                            })),
                            borderColor: isYagermeisterMode ? 'green' : 'blue',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            showLine: true,
                            yAxisID: 'y1',
                        }
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Time (s)',
                            },
                        },
                        y1: {
                            position: 'left',
                            min: 0,
                            max: isYagermeisterMode ? 250 : 13, // Higher max for Y채germeister mode
                            ticks: {
                                stepSize: isYagermeisterMode ? 50 : 1,
                            },
                        },
                        y2: {
                            position: 'right',
                            min: 0,
                            max: 100,
                            ticks: {
                                stepSize: 10,
                            },
                        },
                    },
                    plugins: {
                        tooltip: {
                            mode: 'nearest',
                            intersect: false,
                        },
                        annotation: {
                            annotations: [
                                ...phaseMarkers.map(time => ({
                                    type: 'line',
                                    scaleID: 'x',
                                    value: time,
                                    borderColor: 'gray',
                                    borderWidth: 1,
                                    label: {
                                        content: `Phase`,
                                        position: 'top',
                                    },
                                })),
                                ...phaseAnnotations
                            ],
                        },
                    },
                    onHover: (event, chartElement) => {
                        if (chartElement.length > 0) {
                            const x = chartElement[0].element.x;
                            highlightPhase(x);
                        } else {
                            removeHighlight();
                        }
                    },
                }
            });

            // Add event listeners for hover
            const jsonDisplay = document.getElementById('jsonDisplay');
            const chartCanvas = document.getElementById('myChart');

            function highlightPhase(x) {
                const phases = jsonDisplay.getElementsByClassName('phase');
                phasesData.forEach((phaseData, index) => {
                    if (x >= phaseData.startTime && x <= phaseData.endTime) {
                        phases[index].classList.add('highlight');
                    } else {
                        phases[index].classList.remove('highlight');
                    }
                });
            }

            function removeHighlight() {
                const phases = jsonDisplay.getElementsByClassName('phase');
                for (let i = 0; i < phases.length; i++) {
                    phases[i].classList.remove('highlight');
                }
            }
        }

        // New function to plot Y채germeister profile format
        function plotYagermeisterProfile(data) {
            globalData = data;
            const { profile } = data;
            
            const setpointData = [];
            const timeLabels = [];
            const stepMarkers = [];
            const stepAnnotations = [];
            
            let currentTime = 0;
            
            // Process each step in the profile
            profile.steps.forEach((step, index) => {
                const { duration, setpoint, interpolation } = step;
                
                const startTime = currentTime;
                const endTime = currentTime + duration;
                
                // Convert interpolation to curve type
                let curveType;
                switch (interpolation) {
                    case 'ease-in':
                        curveType = 'EASE_IN';
                        break;
                    case 'ease-out':
                        curveType = 'EASE_OUT';
                        break;
                    default:
                        curveType = 'LINEAR';
                }
                
                // Get previous setpoint value if available
                const prevSetpoint = index > 0 ? profile.steps[index - 1].setpoint : setpoint;
                
                // Generate transition data
                const transitionData = applyTransition(
                    curveType,
                    prevSetpoint, 
                    setpoint,
                    startTime,
                    endTime,
                    duration
                );
                
                setpointData.push(...transitionData);
                
                // Add time labels and markers
                timeLabels.push(startTime, endTime);
                stepMarkers.push(startTime, endTime);
                
                // Add step annotations
                stepAnnotations.push({
                    type: 'line',
                    scaleID: 'x',
                    value: startTime,
                    borderColor: 'gray',
                    borderWidth: 1,
                    label: {
                        content: `Step ${index + 1}`,
                        position: 'start',
                        enabled: true,
                    },
                });
                
                // Store step data for highlighting
                phasesData.push({
                    startTime,
                    endTime,
                    index
                });
                
                currentTime += duration;
            });
            
            const uniqueTimeLabels = [...new Set(timeLabels)].sort((a, b) => a - b);
            
            if (chart) {
                chart.destroy();
            }
            
            chart = new Chart(document.getElementById('myChart'), {
                type: 'line',
                data: {
                    labels: uniqueTimeLabels,
                    datasets: [
                        {
                            label: 'Setpoint',
                            data: setpointData,
                            borderColor: 'green',
                            backgroundColor: 'rgba(0, 255, 0, 0.1)',
                            borderWidth: 3,
                            pointRadius: 0,
                            fill: false,
                            tension: 0.4,
                            yAxisID: 'y1',
                        }
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Time (s)',
                            },
                        },
                        y1: {
                            position: 'left',
                            min: 0,
                            max: 250,
                            ticks: {
                                stepSize: 50,
                            },
                            title: {
                                display: true,
                                text: 'Setpoint',
                            }
                        },
                    },
                    plugins: {
                        tooltip: {
                            mode: 'nearest',
                            intersect: false,
                        },
                        annotation: {
                            annotations: [
                                ...stepMarkers.map(time => ({
                                    type: 'line',
                                    scaleID: 'x',
                                    value: time,
                                    borderColor: 'gray',
                                    borderWidth: 1,
                                })),
                                ...stepAnnotations
                            ],
                        },
                    },
                    onHover: (event, chartElement) => {
                        if (chartElement.length > 0) {
                            const x = chartElement[0].element.x;
                            highlightPhase(x);
                        } else {
                            removeHighlight();
                        }
                    },
                }
            });
            
            function highlightPhase(x) {
                const phases = document.getElementById('jsonDisplay').getElementsByClassName('phase');
                phasesData.forEach((phaseData, index) => {
                    if (x >= phaseData.startTime && x <= phaseData.endTime && phases[index]) {
                        phases[index].classList.add('highlight');
                    } else if (phases[index]) {
                        phases[index].classList.remove('highlight');
                    }
                });
            }
            
            function removeHighlight() {
                const phases = document.getElementById('jsonDisplay').getElementsByClassName('phase');
                for (let i = 0; i < phases.length; i++) {
                    phases[i].classList.remove('highlight');
                }
            }
        }

        // Function to update the JSON display for standard format
        function updateJsonDisplay(data) {
            const jsonDisplay = document.getElementById('jsonDisplay');
            jsonDisplay.innerHTML = ''; // Clear previous content

            // Add id and name at the start
            const initialMetadataSections = ['id', 'name'];
            initialMetadataSections.forEach(section => {
                const metadataDiv = document.createElement('div');
                metadataDiv.className = 'metadata';
                metadataDiv.innerHTML = `<pre contenteditable="true" class="metadata-${section}">${JSON.stringify({ [section]: data[section] }, null, 2)}</pre>`;
                jsonDisplay.appendChild(metadataDiv);
            });

            // Add phases
            const phasesDiv = document.createElement('div');
            phasesDiv.className = 'phases';
            data.phases.forEach((phase, index) => {
                const phaseDiv = document.createElement('div');
                phaseDiv.className = 'phase';
                phaseDiv.innerHTML = `<pre contenteditable="true">${JSON.stringify(phase, null, 2)}</pre>`;
                phasesDiv.appendChild(phaseDiv);
            });
            jsonDisplay.appendChild(phasesDiv);

            // Add remaining metadata sections at the end
            const remainingMetadataSections = ['globalStopConditions', 'waterTemperature', 'recipe'];
            remainingMetadataSections.forEach(section => {
                const metadataDiv = document.createElement('div');
                metadataDiv.className = 'metadata';
                metadataDiv.innerHTML = `<pre contenteditable="true" class="metadata-${section}">${JSON.stringify({ [section]: data[section] }, null, 2)}</pre>`;
                jsonDisplay.appendChild(metadataDiv);
            });

            // Add event listener to update the graph and global data when JSON is modified
            jsonDisplay.addEventListener('input', function(event) {
                if (event.target.tagName === 'PRE') {
                    try {
                        const metadataSections = ['id', 'name', 'globalStopConditions', 'waterTemperature', 'recipe'];
                        const metadata = {};
                        metadataSections.forEach(section => {
                            const metadataDiv = jsonDisplay.querySelector(`.metadata-${section}`);
                            if (metadataDiv) {
                                const parsedData = JSON.parse(metadataDiv.innerText);
                                metadata[section] = parsedData[section];
                            }
                        });

                        const updatedPhases = Array.from(jsonDisplay.getElementsByClassName('phase')).map(phaseDiv => JSON.parse(phaseDiv.innerText));
                        const updatedData = { ...metadata, phases: updatedPhases };
                        globalData = updatedData;
                        plotProfile(updatedData);
                    } catch (error) {
                        console.error('Invalid JSON format:', error);
                    }
                }
            });
        }

        // Function to update JSON display for Y채germeister format
        function updateYagermeisterJsonDisplay(data) {
            const jsonDisplay = document.getElementById('jsonDisplay');
            jsonDisplay.innerHTML = ''; // Clear previous content
            
            // Add profile section header
            const profileHeaderDiv = document.createElement('div');
            profileHeaderDiv.className = 'metadata';
            profileHeaderDiv.innerHTML = `<pre contenteditable="true" class="metadata-profile-header">{"profile": {</pre>`;
            jsonDisplay.appendChild(profileHeaderDiv);
            
            // Add steps header
            const stepsHeaderDiv = document.createElement('div');
            stepsHeaderDiv.className = 'metadata';
            stepsHeaderDiv.innerHTML = `<pre contenteditable="true" class="metadata-steps-header">  "steps": [</pre>`;
            jsonDisplay.appendChild(stepsHeaderDiv);
            
            // Add each step
            const { profile } = data;
            profile.steps.forEach((step, index) => {
                const stepDiv = document.createElement('div');
                stepDiv.className = 'phase';
                
                // Format JSON with proper indentation and comma
                const isLastStep = index === profile.steps.length - 1;
                const stepJson = JSON.stringify(step, null, 2)
                    .replace(/\n/g, '\n    ') // Add extra indentation
                    .replace(/^{/, '    {')   // Indent first line
                    + (isLastStep ? '' : ',');
                
                stepDiv.innerHTML = `<pre contenteditable="true">${stepJson}</pre>`;
                jsonDisplay.appendChild(stepDiv);
            });
            
            // Close JSON structure
            const closingDiv = document.createElement('div');
            closingDiv.className = 'metadata';
            closingDiv.innerHTML = `<pre contenteditable="true" class="metadata-closing">  ]\n}}</pre>`;
            jsonDisplay.appendChild(closingDiv);
            
            // Add event listener for JSON editing
            jsonDisplay.addEventListener('input', function(event) {
                if (event.target.tagName === 'PRE') {
                    try {
                        const steps = [];
                        const stepDivs = jsonDisplay.getElementsByClassName('phase');
                        
                        // Parse each step
                        for (let i = 0; i < stepDivs.length; i++) {
                            const stepText = stepDivs[i].querySelector('pre').innerText
                                .replace(/,$/, ''); // Remove trailing comma if present
                            const step = JSON.parse(stepText);
                            steps.push(step);
                        }
                        
                        // Update global data
                        globalData = {
                            profile: {
                                steps: steps
                            }
                        };
                        
                        // Update chart
                        plotYagermeisterProfile(globalData);
                    } catch (error) {
                        console.error('Invalid JSON format:', error);
                    }
                }
            });
        }

        // Event listener for file input to load and process the JSON data
        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            const reader = new FileReader();

            reader.onload = function(e) {
                const data = JSON.parse(e.target.result);
                
                // Check if the file format is standard or Y채germeister
                if (isYagermeisterMode && data.profile && data.profile.steps) {
                    // Y채germeister format
                    plotYagermeisterProfile(data);
                    updateYagermeisterJsonDisplay(data);
                } else if (!isYagermeisterMode && data.phases) {
                    // Standard format
                    plotProfile(data);
                    updateJsonDisplay(data);
                } else if (isYagermeisterMode && data.phases) {
                    // Convert standard format to Y채germeister format
                    const yagermeisterData = convertToYagermeisterFormat(data);
                    plotYagermeisterProfile(yagermeisterData);
                    updateYagermeisterJsonDisplay(yagermeisterData);
                } else if (!isYagermeisterMode && data.profile && data.profile.steps) {
                    // Convert Y채germeister format to standard format
                    const standardData = convertToStandardFormat(data);
                    plotProfile(standardData);
                    updateJsonDisplay(standardData);
                } else {
                    alert('Invalid JSON format for current mode');
                }
            };

            reader.readAsText(file);
        });

        // Function to convert standard format to Y채germeister format
        function convertToYagermeisterFormat(data) {
            const { phases } = data;
            const steps = phases.map(phase => {
                const { stopConditions, target, type } = phase;
                
                // Convert duration from ms to seconds
                const duration = stopConditions.time ? stopConditions.time / 1000 : 10;
                
                // Use target end value as setpoint
                const setpoint = type === 'PRESSURE' ? target.end * 30 : target.end * 40;
                
                // Map curve types
                let interpolation;
                switch (target.curve) {
                    case 'EASE_IN':
                        interpolation = 'ease-in';
                        break;
                    case 'EASE_OUT':
                        interpolation = 'ease-out';
                        break;
                    case 'EASE_IN_OUT':
                        interpolation = 'ease-out';
                        break;
                    default:
                        interpolation = 'linear';
                }
                
                return {
                    duration,
                    setpoint,
                    interpolation
                };
            });
            
            return {
                profile: {
                    steps
                }
            };
        }

        // Function to convert Y채germeister format to standard format
        function convertToStandardFormat(data) {
            const { profile } = data;
            const phases = profile.steps.map((step, index) => {
                const { duration, setpoint, interpolation } = step;
                
                // Determine if it's pressure or flow based on setpoint range
                const type = setpoint > 100 ? 'PRESSURE' : 'FLOW';
                
                // Scale setpoint value
                const targetEnd = type === 'PRESSURE' ? setpoint / 30 : setpoint / 40;
                
                // Map interpolation
                let curve;
                switch (interpolation) {
                    case 'ease-in':
                        curve = 'EASE_IN';
                        break;
                    case 'ease-out':
                        curve = 'EASE_OUT';
                        break;
                    default:
                        curve = 'LINEAR';
                }
                
                return {
                    name: `Step ${index + 1}`,
                    type,
                    target: {
                        start: index === 0 ? targetEnd : 0, // Start from the same value for simplicity
                        end: targetEnd,
                        curve,
                        time: duration * 1000 // Convert back to ms
                    },
                    restriction: null,
                    stopConditions: {
                        time: duration * 1000,
                        pressureAbove: 0,
                        pressureBelow: 0,
                        flowAbove: 0,
                        flowBelow: 0,
                        weight: 0,
                        waterPumpedInPhase: 0
                    },
                    skip: false,
                    waterTemperature: 0
                };
            });
            
            return {
                id: 1,
                name: "Converted Y채germeister Profile",
                phases,
                globalStopConditions: {
                    time: 0,
                    weight: 0,
                    waterPumped: 0
                },
                waterTemperature: 91,
                recipe: {
                    coffeeIn: 0,
                    coffeeOut: 0,
                    ratio: 0
                }
            };
        }

        // Event listener for export button
        document.getElementById('exportButton').addEventListener('click', function() {
            let jsonData;
            
            if (isYagermeisterMode) {
                // Export Y채germeister format
                jsonData = globalData;
            } else {
                // Export standard format
                jsonData = {
                    id: globalData.id,
                    name: globalData.name,
                    phases: globalData.phases,
                    globalStopConditions: globalData.globalStopConditions,
                    waterTemperature: globalData.waterTemperature,
                    recipe: globalData.recipe
                };
            }

            // Create a blob and download link
            const blob = new Blob([JSON.stringify(jsonData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            // Set filename based on mode
            if (isYagermeisterMode) {
                a.download = `yagermeister_profile.json`;
            } else {
                a.download = `${globalData.name || 'profile'}.json`;
            }
            
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // Event listener for load example button
        document.getElementById('loadExampleButton').addEventListener('click', function() {
            if (isYagermeisterMode) {
                // Load Y채germeister example
                const exampleData = {
                    profile: {
                        steps: [
                            {
                                duration: 10,
                                setpoint: 40,
                                interpolation: "linear",
                            },
                            {
                                duration: 30,
                                setpoint: 80,
                                interpolation: "ease-out",
                            },
                            {
                                duration: 33,
                                setpoint: 150,
                                interpolation: "ease-in",
                            },
                            {
                                duration: 15,
                                setpoint: 210,
                                interpolation: "linear",
                            },
                        ],
                    },
                };
                plotYagermeisterProfile(exampleData);
                updateYagermeisterJsonDisplay(exampleData);
            } else {
                // Load standard example
                const exampleData = {
                    "id": 1,
                    "name": "Example Profile",
                    "phases": [
                        {
                            "name": "",
                            "type": "FLOW",
                            "target": {
                                "start": 4,
                                "end": 4,
                                "curve": "INSTANT",
                                "time": 0
                            },
                            "restriction": 2,
                            "stopConditions": {
                                "time": 10000,
                                "pressureAbove": 2,
                                "pressureBelow": 0,
                                "flowAbove": 0,
                                "flowBelow": 0,
                                "weight": 1,
                                "waterPumpedInPhase": 60
                            },
                            "skip": false,
                            "waterTemperature": 0
                        },
                        {
                            "name": "",
                            "type": "PRESSURE",
                            "target": {
                                "start": 2,
                                "end": 8,
                                "curve": "EASE_IN_OUT",
                                "time": 4000
                            },
                            "restriction": 3.5,
                            "stopConditions": {
                                "time": 5000,
                                "pressureAbove": 0,
                                "pressureBelow": 0,
                                "flowAbove": 0,
                                "flowBelow": 0,
                                "weight": 0,
                                "waterPumpedInPhase": 0
                            },
                            "skip": false,
                            "waterTemperature": 0
                        }
                    ],
                    "globalStopConditions": {
                        "time": 0,
                        "weight": 38,
                        "waterPumped": 0
                    },
                    "waterTemperature": 91,
                    "recipe": {
                        "coffeeIn": 0,
                        "coffeeOut": 0,
                        "ratio": 0
                    }
                };
                plotProfile(exampleData);
                updateJsonDisplay(exampleData);
            }
        });

        // Event listener for add phase button
        document.getElementById('addPhaseButton').addEventListener('click', function() {
            if (isYagermeisterMode) {
                // Add a new step to Y채germeister profile
                if (!globalData.profile) {
                    globalData.profile = { steps: [] };
                }
                
                const newStep = {
                    duration: 10,
                    setpoint: 40,
                    interpolation: "linear"
                };
                
                globalData.profile.steps.push(newStep);
                plotYagermeisterProfile(globalData);
                updateYagermeisterJsonDisplay(globalData);
            } else {
                // Add a new phase to standard profile
                const newPhase = {
                    "name": "",
                    "type": "FLOW",
                    "target": {
                        "start": 0,
                        "end": 0,
                        "curve": "INSTANT",
                        "time": 0
                    },
                    "restriction": 0,
                    "stopConditions": {
                        "time": 5000,
                        "pressureAbove": 0,
                        "pressureBelow": 0,
                        "flowAbove": 0,
                        "flowBelow": 0,
                        "weight": 0,
                        "waterPumpedInPhase": 0
                    },
                    "skip": false,
                    "waterTemperature": 0
                };

                globalData.phases.push(newPhase);
                updateJsonDisplay(globalData);
                plotProfile(globalData);
            }
        });

        // Event listener for remove phase button
        document.getElementById('removePhaseButton').addEventListener('click', function() {
            if (isYagermeisterMode) {
                // Remove the last step from Y채germeister profile
                if (globalData.profile && globalData.profile.steps && globalData.profile.steps.length > 0) {
                    globalData.profile.steps.pop();
                    plotYagermeisterProfile(globalData);
                    updateYagermeisterJsonDisplay(globalData);
                }
            } else {
                // Remove the last phase from standard profile
                if (globalData.phases && globalData.phases.length > 0) {
                    globalData.phases.pop();
                    updateJsonDisplay(globalData);
                    plotProfile(globalData);
                }
            }
        });

        // Event listener for export graph button
        document.getElementById('exportGraphButton').addEventListener('click', function() {
            const chartCanvas = document.getElementById('myChart');
            html2canvas(chartCanvas).then(canvas => {
                canvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    
                    // Set filename based on mode
                    if (isYagermeisterMode) {
                        a.download = `yagermeister_graph.png`;
                    } else {
                        a.download = `${globalData.name || 'profile'}_graph.png`;
                    }
                    
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 'image/png');
            });
        });

        // Event listener for Y채germeister mode toggle button
        document.getElementById('toggleYagermeisterButton').addEventListener('click', function() {
            document.body.classList.toggle('yagermeister-mode');
            isYagermeisterMode = document.body.classList.contains('yagermeister-mode');

            if (isYagermeisterMode) {
                console.log('Y채germeister Mode Activated');
                
                // Convert current data to Y채germeister format if needed
                if (globalData.phases) {
                    const yagermeisterData = convertToYagermeisterFormat(globalData);
                    globalData = yagermeisterData;
                } else if (!globalData.profile) {
                    // If no data loaded yet, load the example
                    globalData = {
                        profile: {
                            steps: [
                                {
                                    duration: 10,
                                    setpoint: 40,
                                    interpolation: "linear",
                                },
                                {
                                    duration: 30,
                                    setpoint: 80,
                                    interpolation: "ease-out",
                                },
                                {
                                    duration: 33,
                                    setpoint: 150,
                                    interpolation: "ease-in",
                                },
                                {
                                    duration: 15,
                                    setpoint: 210,
                                    interpolation: "linear",
                                },
                            ],
                        },
                    };
                }
                
                // Update display and plot
                plotYagermeisterProfile(globalData);
                updateYagermeisterJsonDisplay(globalData);
                
                // Update button text
                this.textContent = 'Standard Mode';
            } else {
                console.log('Y채germeister Mode Deactivated');
                
                // Convert current data to standard format if needed
                if (globalData.profile) {
                    const standardData = convertToStandardFormat(globalData);
                    globalData = standardData;
                }
                
                // Update display and plot
                plotProfile(globalData);
                updateJsonDisplay(globalData);
                
                // Update button text
                this.textContent = 'Y채germeister Mode';
            }
        });

        // Load example data on page load
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('loadExampleButton').click();
        });
    </script>
</body>
</html>